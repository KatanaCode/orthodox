# Automatically generated by the orthodox gem (https://github.com/katanacode/orthodox)
# (c) Copyright 2019 Katana Code Ltd. All Rights Reserved. 
#
# == Schema Information
#
# Table name: password_reset_tokens
#
#  id             :bigint           not null, primary key
#  expires_at     :datetime
#  resetable_type :string           not null
#  secret         :string
#  created_at     :datetime         not null
#  updated_at     :datetime         not null
#  resetable_id   :bigint           not null
#
# Indexes
#
#  index_password_reset_tokens_on_expires_at                       (expires_at)
#  index_password_reset_tokens_on_resetable_type_and_resetable_id  (resetable_type,resetable_id)
#  index_password_reset_tokens_on_secret                           (secret) UNIQUE
#

require 'rails_helper'

RSpec.describe PasswordResetToken, type: :model do
  
  include ActiveSupport::Testing::TimeHelpers
  
  describe "#secret" do
      
    let(:password_reset_token) do
      token = PasswordResetToken.new(resetable_id: 1, resetable_type: "User")
      token.save(validate: false)
      token
    end
    
    it "is set on creation" do
      expect(password_reset_token.secret).to be_present
    end
    
    it "is readonly" do
      original_secret = password_reset_token.secret
      password_reset_token.secret = "somenewvalue"
      password_reset_token.save(validate: false)
      password_reset_token.reload
      expect(password_reset_token.secret).to eql(original_secret)
    end
    
  end

  describe "#expires_at" do
      
    let(:password_reset_token) do
      token = PasswordResetToken.new(resetable_id: 1, resetable_type: "User")
      token.save(validate: false)
      token
    end
    
    it "is set on creation" do
      expect(password_reset_token.expires_at).to be_present
    end
    
    it "is readonly" do
      original_expires_at = password_reset_token.expires_at
      password_reset_token.expires_at = 1.day.from_now
      password_reset_token.save(validate: false)
      password_reset_token.reload
      expect(password_reset_token.expires_at).to eql(original_expires_at)
    end
    
  end

  describe "#resetable_id" do
      
    let(:password_reset_token) do
      token = PasswordResetToken.new(resetable_id: 1, resetable_type: "User")
      token.save(validate: false)
      token
    end
    
    it "is set on creation" do
      expect(password_reset_token.resetable_id).to be_present
    end
    
    it "is readonly" do
      original_resetable_id = password_reset_token.resetable_id
      password_reset_token.resetable_id = 1.day.from_now
      password_reset_token.save(validate: false)
      password_reset_token.reload
      expect(password_reset_token.resetable_id).to eql(original_resetable_id)
    end
    
  end
    
  describe "#resetable_type" do
      
    let(:password_reset_token) do
      token = PasswordResetToken.new(resetable_id: 1, resetable_type: "User")
      token.save(validate: false)
      token
    end
    
    it "is set on creation" do
      expect(password_reset_token.resetable_type).to be_present
    end
    
    it "is readonly" do
      original_resetable_type = password_reset_token.resetable_type
      password_reset_token.resetable_type = 1.day.from_now
      password_reset_token.save(validate: false)
      password_reset_token.reload
      expect(password_reset_token.resetable_type).to eql(original_resetable_type)
    end
    
  end
  
  describe "#expired?" do
    
    let(:password_reset_token) do
      token = PasswordResetToken.new(resetable_id: 1, resetable_type: "User")
      token.save(validate: false)
      token
    end
    
    context "when still within time threshhold" do
      
      it "is not expired" do
        expect(password_reset_token).not_to be_expired
      end
      
    end

    context "when outwith time threshhold" do
      
      it "is expected to be false" do
        password_reset_token
        travel(16.minutes) do
          expect(password_reset_token).to be_expired
        end
      end
      
    end
    
  end
  
end
